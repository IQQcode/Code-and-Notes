### 死锁

死锁参生的条件(**下列四个条件必须同时满足**)：

1. 互斥
   - 共享资源只能同时被一个线程占用
2. 占有且等待
   - 拿到了一个锁，不释放的同时又去申请另一个锁
3. 不可抢占
   - 线程不能强行抢占其他线程的锁
4. 循环等待
   - 线程T1等待线程T2占有的资源，线程T2又等待线程T1占有的资源

> 解决死锁的思路：破坏参生条件的任意一个

==银行家算法---->解决死锁问题==



### ThreadLocal

**ThreadLocal----线程本地变量（属于线程私有资源，不与其他线程共享）**

`set()`设置线程私有属性值

`get()`取得线程私有属性值

* 在使用 ThreadLocal 类型变量进行相关操作时，都会通过当前线程获取到 ThreadLocalMap 来完成操作。

* 每个线程的 `ThreadLocalMap `(存放元素)是属于线程自己的，`ThreadLocalMap` 中维护的值也是属于线程自己的。这就保证了`ThreadLocal` 类型的变量在每个线程中是独立的，在多线程环境下不会相互影响



### Object类的 wait() 、noyify()

Object: wait()  notify()必须搭配synchronized使用

使用wait(),notify()的前提： **必须在同步方法或同步代码块中使用(拿到相应对象的锁)**，如果没有`synchronized`会抛出` java.lang.IllegalMonitorStateException`（非法监视器状态异常）



#### wait():痴汉方法

持有锁的线程调用`wait()`后会一直阻塞，直到有线程调用`notify()`将其唤醒

**wait()的重载方法：**

```java
public final native void wait(long timeout)
```

等待一段时间，若还未被唤醒，继续执行，默认单位为ms

#### notify():

唤醒任意==一个==处于等待状态的线程（notify方法就是使停止的线程继续运行）

![1564115582690](C:\Users\j2726\AppData\Roaming\Typora\typora-user-images\1564115582690.png)任意一个Object及其子类对象都有来个队列：

- 同步队列：所有尝试获取该对象`Monitor`失败的线程，都加入同步队列，排队获取
- 等待队列：已经拿到了锁的线程在等待其他资源时，主动释放锁，置入该对象等待队列中，等待其被唤醒；当调用`notify()`会在等待队列中任意唤醒一个线程，将其**置入到同步队列尾部，排队获取锁**

#### notifyAll()

将等待队列中的所有线程唤醒，并且加入到同步队列

### 生产消费者模型

>* 生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。
>
>* 这个阻塞队列就是用来给生产者和消费者解耦的。大多数设计模式，都会找一个第三者出来进行解耦，如工厂模式的第三者是工厂类，模板模式的第三者是模板类。在学习一些设计模式的过程中，如果先找到这个模式的第三者，能帮助我们快速熟悉一个设计模式







