###  JDK1.6 之后对synchronized的优化

synchronized的操作都是互斥的，效率较低(举例子)

优化的思想：让每个线程通过同步代码快时的速度提高

- CAS(自旋) 操作(无锁实现的同步---乐观锁)** Compare And Swap

  ```java
  class Test {
      int i = 0;
      //线程1先进入同步代码块
      //线程2再进入
      synchronized(this) {
          i = 10;
      }
  }
  ```

  CompareAndSwap(O, V, N)

  O:当前线程存储的变量值

  V:内存中该变量的具体值

  N：希望修改后的变量值

  > **线程1先进入同步代码块：**
  >
  > O ----> i = 0
  >
  > V  ----> i = 0
  >
  > O  == V    
  >
  > N ---->  i = 10
  >
  > **线程2再进入同步代码块：**
  >
  > O ----> i = 0
  >
  > V  ----> i = 10
  >
  > O  != V    
  >
  > N ---->  修改失败

  当 O == V 时，此时表示还没有线程修改共享变量的值，此时可以成功的将内存中的值修改为N

  当 O != V 时，表示此时内存中的共享变量值已经被其他线程修改，此时返回内存中的最新值V,在此尝试修改

  过红绿灯：

​       线程挂起阻塞：车熄火

​       自旋： 脚踩刹车，车不熄火

- 自旋带来的问题： ABA问题

  - 解决方法： 添加版本号 A.1----> B.2

    

- 自旋在CPU上跑无用指令，虽然减少了操作系统的开销，但是浪费了CPU资源
  
  - JVM自适应自旋 ：根据以往自旋等待时能否获取锁，来动态调整自旋的时间(循环数)
  
- JVM尝试自旋一段时间，若在此时间内线程成功获取到锁，在下次获取锁时，适当延长自旋时间；若在此时间内线程没有获取到锁，在下次获取锁时，适当缩短自旋时间
  
    
  
- 公平性问题

  ​       处于阻塞状态的线程可能一直服务法获取到锁，自旋状态的线程更能容易获取到锁

  ​       Lock锁可以实现公平性，synchronized无法实现公平锁

- **偏向锁：**

  JDK 1.6 之后默认synchronized

  最乐观的锁：进入同步块或同步方法始终是一个线程

  在不同时刻时，当出现另一个线程也尝试获取锁，偏向锁会升级为轻量级锁

- **轻量级锁**
  - 不同时刻有不同的线程获取锁，“亮黄灯策略”，基本不存在锁竞争
  - 同一时可如果不同线程尝试获取锁，会将偏向锁自动升级为重量级锁

- **重量级锁**

  JDK 1.6 之前的锁都是重量级锁，将线程阻塞挂起

  锁只有升级过程，没有降级

- **锁粗化**

  将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成为一个范围更大的锁

  ```java
  public class Test {
      private static StringBuffer sb = new StringBuffer();
      public static void main(String[] args) {
          sb.append("a");
          sb.append("b");
          sb.append("c");
      }
  }
  ```

  这里每次调用stringBuffer.append方法都需要加锁和解锁

  如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次`append`方法时进行加锁，最后一次`append`方法结束后进行解锁

- **锁消除**

​        当对象不属于共享资源时，对象内部的同步方法或同步代码块的锁会被自动解除

```java
public class Test {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer();
        sb.append("a").append("b").append("c");
    }
}
```





​    



